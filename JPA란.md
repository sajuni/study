# JPA란?
JPA(Java Persistence API)는 자바진영 ORM 기술이다. 

# ORM(Object Relational Mapping)
객체와 테이블을 매핑한다. 기술적으로는 객체를 RDB 테이블에 자동으로 영속화 해서 관리하게 해준다.

### 장점
- SQL문이 아닌 Method를 통해 DB를 조작할 수 있어, 개발자는 객체 모델을 이용하여 비즈니스 로직을 구성하는데만 집중할 수 있다.
(내부적으로는 쿼리를 생성하여 DB를 좆가함. 하지만 개발자는 이를 신경 X)
- 객체지향적인 코드 작성이 가능하다. 오직 객체지향적 접근만 고려하면 되기때문에 생상성 증가
- 매핑하는 정보가 Class로 명시 되어있기 때문에 ERD를 보는 의존도를 낮출 수 있고 유지보수 및 리팩토링에 유리하다.
- 예시로 기존 방식에서 MySQL DB를 사용하다가 Oracle로 변경 시 새로 쿼리를 짜야하지만 ORM을 사용한다면 쿼리를 수정하지 않아도 된다.
- ISERT, UPDATE, DELETE, 테이블 생성문 등을 직접 작성하지 않고 JPA 메소드를 호출해 사용하거나 자동으로 생성해주기 때문에 생성성이 좋아진다.

### 단점
- 프로젝트 규모가 크고 복잡하여 설계가 잘못된 경우, 속도 저하 및 일관성을 무너뜨리는 문제점이 생길 수 있다.
- 복잡하고 무거운 Query는 속도를 위해 별도의 튜닝이 필요하기 때문에 결국 SQL문을 써야할 수도 있다.
- 학습비용이 비싸다.

## N+1문제
### When 언제 발생하는가?
- JPA Repository를 활용해 인터페이스 메소드를 호출할 때(Read 시)

### Who 누가 발생시키는가?
- 1:N 또는 N:1 관계를 가진 엔티티를 조회할 때 발생

### How 어떤 상황에 발생되는가?
- JPA Fetch 전략이 EAGER 전략으로 데이터를 조회하는 경우
- JPQ Fetch 전략이 LAZY 전략으로 데이터를 가져온 이후에 연관 관계인 하위 엔티티를 다시 조회하는 경우

### Why 왜 발생하는가?
- JPA Repository로 find 시 실행하는 첫 쿼리에서 하위 엔티티까지 한 번에 가져오지 않고, 하위 엔티티를 사용할 때 추가로 조회하기 때문에
- JPQL은 기본적으로 글로벌 Fetch 전략을 무시하고 JPQL만 가지고 SQL을 생성하기 때문에.

1. Fetch Join(패치 조인)
N+1 문제가 발생하는 이유는 한쪽 테이블만 조회하고 연결된 다른 테이블은 따로 조회하기 때문이다. 
**미리 두 테이블을 JOIN 하여 한 번에 모든 데이터를 가져올 수 있다면 애초에 N+1 문제가 발생하지 않을 것이다.**
그렇게 나온 해결 방법이 FetchJoin 방법이다.
두 테이블을 JOIN하는 쿼리를 직접 작성하는 것이다.
다음과 같이 JPQL을 직접 지정해준다.

### Fetch Join(패치 조인)의 단점
- 쿼리 한번에 모든 데이터를 가져오기 때문에 JPA가 제공하는 Paging API 사용 불가능(Pageable 사용 불가)
- 1:N 관계가 두 개 이상인 경우 사용 불가
- 패치 조인 대상에게 별칭(as) 부여 불가능
- 번거롭게 쿼리문을 작성해야 함